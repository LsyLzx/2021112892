<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TextGraph.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">TextGraphTest 覆盖结果</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">TextGraph.java</span></div><h1>TextGraph.java</h1><pre class="source lang-java linenums">
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Random;
import java.util.Random;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Supplier;
import javax.swing.SwingUtilities;
import org.apache.commons.io.FilenameUtils;

final class TextGraph {
  private Map&lt;String, Map&lt;String, Integer&gt;&gt; graph;
  private String firstWord;

<span class="fc" id="L32">  public TextGraph() {</span>
<span class="fc" id="L33">    graph = new HashMap&lt;&gt;();</span>
<span class="fc" id="L34">  }</span>

  public void readTextFile(String filePath) throws IOException {
<span class="fc" id="L37">    graph = new HashMap&lt;&gt;();</span>
    // 读取指定路径的文件内容
<span class="fc" id="L39">    List&lt;String&gt; lines = Files.readAllLines(Paths.get(filePath));</span>
<span class="fc" id="L40">    String text = String.join(&quot; &quot;, lines).toLowerCase(); // 将列表中的所有行合并成一个字符串，并转换为小写</span>
<span class="fc" id="L41">    text = text.replaceAll(&quot;[^a-z ]&quot;, &quot; &quot;); // 使用正则表达式将所有非小写字母和空格的字符替换为空格</span>
<span class="fc" id="L42">    String[] words = text.split(&quot;\\s+&quot;); // 使用正则表达式将文本字符串按一个或多个空白字符拆分成单词数组</span>
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">    if (words.length &gt; 0) { // 如果单词数组非空，将第一个单词设置为图的起始点</span>
<span class="fc" id="L44">      firstWord = words[0];</span>
    }

    // 遍历单词数组，从第一个单词到倒数第二个单词，目的是构建单词之间的边
<span class="fc bfc" id="L48" title="All 2 branches covered.">    for (int i = 0; i &lt; words.length - 1; i++) {</span>
      // 当前单词和下一个单词
<span class="fc" id="L50">      String word1 = words[i];</span>
<span class="fc" id="L51">      String word2 = words[i + 1];</span>
<span class="fc" id="L52">      graph.putIfAbsent(word1, new HashMap&lt;&gt;()); // 确保图中包含word1节点，如果没有，则添加一个新的空邻居列表</span>
      // 确保图中包含word2节点，如果没有，则添加一个新的空邻居列表
<span class="fc" id="L54">      graph.putIfAbsent(word2, new HashMap&lt;&gt;());</span>
      // 获取word1的邻居列表，将word2添加到该列表中
      // 使用getOrDefault方法获取从word1到word2的当前权重（默认值为0），然后将权重加1
<span class="fc" id="L57">      graph.get(word1).put(word2, graph.get(word1).getOrDefault(word2, 0) + 1);</span>
    }
<span class="fc" id="L59">  }</span>


  public Map&lt;String, Map&lt;String, Integer&gt;&gt; getGraph() {
<span class="nc" id="L63">    return graph;</span>
  }

  public String getFirstWord() {
<span class="nc" id="L67">    return firstWord;</span>
  }

  public void printGraph() {
    // Use entrySet() to iterate over map entries directly
<span class="nc bnc" id="L72" title="All 2 branches missed.">    for (Map.Entry&lt;String, Map&lt;String, Integer&gt;&gt; outerEntry : graph.entrySet()) {</span>
<span class="nc" id="L73">      String from = outerEntry.getKey();</span>
<span class="nc" id="L74">      Map&lt;String, Integer&gt; innerMap = outerEntry.getValue();</span>

<span class="nc" id="L76">      System.out.print(from + &quot; -&gt; &quot;);</span>

      // Continue to use entrySet() for the inner map
<span class="nc bnc" id="L79" title="All 2 branches missed.">      for (Map.Entry&lt;String, Integer&gt; entry : innerMap.entrySet()) {</span>
<span class="nc" id="L80">        System.out.print(entry.getKey() + &quot; (&quot; + entry.getValue() + &quot;) &quot;);</span>
<span class="nc" id="L81">      }</span>

<span class="nc" id="L83">      System.out.println();</span>
<span class="nc" id="L84">    }</span>
<span class="nc" id="L85">  }</span>


  //查询桥接词
  public String queryBridgeWords(String word1, String word2) {
<span class="fc bfc" id="L90" title="All 2 branches covered.">    if (!graph.containsKey(word1)</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">            &amp;&amp; !graph.containsKey(word2)) {</span>
<span class="fc" id="L92">      return &quot;No \&quot;&quot; + word1 + &quot;\&quot; and \&quot;&quot; + word2 + &quot;\&quot; in the graph!&quot;;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">    } else if (!graph.containsKey(word1)) {</span>
<span class="fc" id="L94">      return &quot;No \&quot;&quot; + word1 + &quot;\&quot; in the graph!&quot;;</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">    } else if (!graph.containsKey(word2)) {</span>
<span class="fc" id="L96">      return &quot;No \&quot;&quot; + word2 + &quot;\&quot; in the graph!&quot;;</span>
    }

<span class="fc" id="L99">    Set&lt;String&gt; bridgeWords = new HashSet&lt;&gt;();</span>
<span class="fc" id="L100">    Map&lt;String, Integer&gt; neighbors = graph.get(word1); //单词1的所有邻接词</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">    for (String neighbor : neighbors.keySet()) {</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">      if (graph.get(neighbor).containsKey(word2)) { //设置中间词的连接词是word2</span>
<span class="fc" id="L103">        bridgeWords.add(neighbor);</span>
      }
<span class="fc" id="L105">    }</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">    if (bridgeWords.isEmpty()) {</span>
<span class="fc" id="L108">      return &quot;No bridge words from \&quot;&quot; + word1 + &quot;\&quot; to \&quot;&quot; + word2 + &quot;\&quot;!&quot;;</span>
    } else {
      String result;
<span class="fc bfc" id="L111" title="All 2 branches covered.">      if (bridgeWords.size() &gt; 1) {</span>
<span class="fc" id="L112">        result = &quot;The bridge words from \&quot;&quot; + word1 + &quot;\&quot; to \&quot;&quot; + word2 + &quot;\&quot; are: &quot;;</span>
      } else {
<span class="fc" id="L114">        result = &quot;The bridge words from \&quot;&quot; + word1 + &quot;\&quot; to \&quot;&quot; + word2 + &quot;\&quot; is: &quot;;</span>
      }
<span class="fc" id="L116">      result += String.join(&quot;, &quot;, bridgeWords);</span>
<span class="fc" id="L117">      return result;</span>
    }
  }

  //生成桥接词
  public String generateNewText(String inputText) {
<span class="nc" id="L123">    String[] words = inputText.toLowerCase().split(&quot;\\s+&quot;);</span>
<span class="nc" id="L124">    StringBuilder newText = new StringBuilder();</span>
<span class="nc" id="L125">    Random rand = new SecureRandom();</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">    for (int i = 0; i &lt; words.length - 1; i++) {</span>
<span class="nc" id="L128">      newText.append(words[i]).append(&quot; &quot;);</span>
<span class="nc" id="L129">      String word1 = words[i];</span>
<span class="nc" id="L130">      String word2 = words[i + 1];</span>
<span class="nc" id="L131">      Set&lt;String&gt; bridgeWords = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L133" title="All 2 branches missed.">      if (graph.containsKey(word1)) {</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        for (String neighbor : graph.get(word1).keySet()) {</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">          if (graph.get(neighbor).containsKey(word2)) {</span>
<span class="nc" id="L136">            bridgeWords.add(neighbor);</span>
          }
<span class="nc" id="L138">        }</span>
      }

<span class="nc bnc" id="L141" title="All 2 branches missed.">      if (!bridgeWords.isEmpty()) {</span>
<span class="nc" id="L142">        String[] bridges = bridgeWords.toArray(new String[0]);</span>
<span class="nc" id="L143">        String bridgeWord = bridges[rand.nextInt(bridges.length)];</span>
<span class="nc" id="L144">        newText.append(bridgeWord).append(&quot; &quot;);</span>
      }
    }
<span class="nc" id="L147">    newText.append(words[words.length - 1]);</span>

<span class="nc" id="L149">    return newText.toString();</span>
  }


  //计算最短路
  public String calcShortestPath(String word1, String word2) {
<span class="nc bnc" id="L155" title="All 4 branches missed.">    if (!graph.containsKey(word1) || !graph.containsKey(word2)) {</span>
<span class="nc bnc" id="L156" title="All 4 branches missed.">      if (!graph.containsKey(word1) &amp;&amp; !graph.containsKey(word2)) {</span>
<span class="nc" id="L157">        return &quot;No \&quot;&quot; + word1 + &quot;\&quot; and \&quot;&quot; + word2 + &quot;\&quot; in the graph!&quot;;</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">      } else if (!graph.containsKey(word1)) {</span>
<span class="nc" id="L159">        return &quot;No \&quot;&quot; + word1 + &quot;\&quot; in the graph!&quot;;</span>
      } else {
<span class="nc" id="L161">        return &quot;No \&quot;&quot; + word2 + &quot;\&quot; in the graph!&quot;;</span>
      }
    }

<span class="nc" id="L165">    Map&lt;String, Integer&gt; distances = new HashMap&lt;&gt;();</span>
<span class="nc" id="L166">    Map&lt;String, String&gt; previousNodes = new HashMap&lt;&gt;();</span>
<span class="nc" id="L167">    PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(distances::get));</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">    for (String node : graph.keySet()) {</span>
<span class="nc" id="L170">      distances.put(node, Integer.MAX_VALUE);</span>
<span class="nc" id="L171">      previousNodes.put(node, null);</span>
<span class="nc" id="L172">    }</span>

<span class="nc" id="L174">    distances.put(word1, 0);</span>
<span class="nc" id="L175">    pq.add(word1);</span>

<span class="nc bnc" id="L177" title="All 2 branches missed.">    while (!pq.isEmpty()) {</span>
<span class="nc" id="L178">      String current = pq.poll();</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">      if (current.equals(word2)) {</span>
<span class="nc" id="L180">        break;</span>
      }

<span class="nc bnc" id="L183" title="All 2 branches missed.">      for (Map.Entry&lt;String, Integer&gt; neighbor : graph.get(current).entrySet()) {</span>
<span class="nc" id="L184">        int newDist = distances.get(current) + neighbor.getValue();</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (newDist &lt; distances.get(neighbor.getKey())) {</span>
<span class="nc" id="L186">          distances.put(neighbor.getKey(), newDist);</span>
<span class="nc" id="L187">          previousNodes.put(neighbor.getKey(), current);</span>
<span class="nc" id="L188">          pq.add(neighbor.getKey());</span>
        }
<span class="nc" id="L190">      }</span>
<span class="nc" id="L191">    }</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">    if (distances.get(word2) == Integer.MAX_VALUE) {</span>
<span class="nc" id="L194">      return &quot;No path from \&quot;&quot; + word1 + &quot;\&quot; to \&quot;&quot; + word2 + &quot;\&quot;!&quot;;</span>
    }

<span class="nc" id="L197">    List&lt;String&gt; path = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">    for (String at = word2; at != null; at = previousNodes.get(at)) {</span>
<span class="nc" id="L199">      path.add(at);</span>
    }
<span class="nc" id="L201">    Collections.reverse(path);</span>

    StringBuilder result;
<span class="nc" id="L204">    result = new StringBuilder(&quot;Shortest path from \&quot;&quot; + word1 + &quot;\&quot; to \&quot;&quot; + word2 + &quot;\&quot;: &quot;);</span>
<span class="nc" id="L205">    result.append(String.join(&quot; -&gt; &quot;, path));</span>
<span class="nc" id="L206">    result.append(&quot; (Total weight: &quot;).append(distances.get(word2)).append(&quot;)&quot;);</span>

<span class="nc" id="L208">    return result.toString();</span>
  }

  //得到最短路
  public List&lt;String&gt; getShortestPath(String word1, String word2) {
<span class="nc bnc" id="L213" title="All 4 branches missed.">    if (!graph.containsKey(word1) || !graph.containsKey(word2)) {</span>
<span class="nc" id="L214">      return Collections.emptyList();</span>
    }

<span class="nc" id="L217">    Map&lt;String, Integer&gt; distances = new HashMap&lt;&gt;();</span>
<span class="nc" id="L218">    Map&lt;String, String&gt; previousNodes = new HashMap&lt;&gt;();</span>
<span class="nc" id="L219">    PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(distances::get));</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">    for (String node : graph.keySet()) {</span>
<span class="nc" id="L222">      distances.put(node, Integer.MAX_VALUE);</span>
<span class="nc" id="L223">      previousNodes.put(node, null);</span>
<span class="nc" id="L224">    }</span>

<span class="nc" id="L226">    distances.put(word1, 0);</span>
<span class="nc" id="L227">    pq.add(word1);</span>

<span class="nc bnc" id="L229" title="All 2 branches missed.">    while (!pq.isEmpty()) {</span>
<span class="nc" id="L230">      String current = pq.poll();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (current.equals(word2)) {</span>
<span class="nc" id="L232">        break;</span>
      }

<span class="nc bnc" id="L235" title="All 2 branches missed.">      for (Map.Entry&lt;String, Integer&gt; neighbor : graph.get(current).entrySet()) {</span>
<span class="nc" id="L236">        int newDist = distances.get(current) + neighbor.getValue();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (newDist &lt; distances.get(neighbor.getKey())) {</span>
<span class="nc" id="L238">          distances.put(neighbor.getKey(), newDist);</span>
<span class="nc" id="L239">          previousNodes.put(neighbor.getKey(), current);</span>
<span class="nc" id="L240">          pq.add(neighbor.getKey());</span>
        }
<span class="nc" id="L242">      }</span>
<span class="nc" id="L243">    }</span>

<span class="nc bnc" id="L245" title="All 2 branches missed.">    if (distances.get(word2) == Integer.MAX_VALUE) {</span>
<span class="nc" id="L246">      return Collections.emptyList();</span>
    }

<span class="nc" id="L249">    List&lt;String&gt; path = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    for (String at = word2; at != null; at = previousNodes.get(at)) {</span>
<span class="nc" id="L251">      path.add(at);</span>
    }
<span class="nc" id="L253">    Collections.reverse(path);</span>

<span class="nc" id="L255">    return path;</span>
  }

  public Map&lt;String, List&lt;String&gt;&gt; calcShortestPathsFrom(String word) {
<span class="nc" id="L259">    Map&lt;String, List&lt;String&gt;&gt; shortestPaths = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">    if (!graph.containsKey(word)) {</span>
<span class="nc" id="L261">      return shortestPaths;</span>
    }

<span class="nc" id="L264">    Map&lt;String, Integer&gt; distances = new HashMap&lt;&gt;();</span>
<span class="nc" id="L265">    Map&lt;String, String&gt; previousNodes = new HashMap&lt;&gt;();</span>
<span class="nc" id="L266">    PriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(distances::get));</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">    for (String node : graph.keySet()) {</span>
<span class="nc" id="L269">      distances.put(node, Integer.MAX_VALUE);</span>
<span class="nc" id="L270">      previousNodes.put(node, null);</span>
<span class="nc" id="L271">    }</span>

<span class="nc" id="L273">    distances.put(word, 0);</span>
<span class="nc" id="L274">    pq.add(word);</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">    while (!pq.isEmpty()) {</span>
<span class="nc" id="L277">      String current = pq.poll();</span>

<span class="nc bnc" id="L279" title="All 2 branches missed.">      for (Map.Entry&lt;String, Integer&gt; neighbor : graph.get(current).entrySet()) {</span>
<span class="nc" id="L280">        int newDist = distances.get(current) + neighbor.getValue();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (newDist &lt; distances.get(neighbor.getKey())) {</span>
<span class="nc" id="L282">          distances.put(neighbor.getKey(), newDist);</span>
<span class="nc" id="L283">          previousNodes.put(neighbor.getKey(), current);</span>
<span class="nc" id="L284">          pq.add(neighbor.getKey());</span>
        }
<span class="nc" id="L286">      }</span>
<span class="nc" id="L287">    }</span>

<span class="nc bnc" id="L289" title="All 2 branches missed.">    for (String target : graph.keySet()) {</span>
<span class="nc bnc" id="L290" title="All 4 branches missed.">      if (!target.equals(word) &amp;&amp; distances.get(target) != Integer.MAX_VALUE) {</span>
<span class="nc" id="L291">        List&lt;String&gt; path = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        for (String at = target; at != null; at = previousNodes.get(at)) {</span>
<span class="nc" id="L293">          path.add(at);</span>
        }
<span class="nc" id="L295">        Collections.reverse(path);</span>
<span class="nc" id="L296">        shortestPaths.put(target, path);</span>
      }
<span class="nc" id="L298">    }</span>
<span class="nc" id="L299">    return shortestPaths;</span>
  }

  //随机游走
  public String randomWalk(Supplier&lt;Boolean&gt; stopSignal, Consumer&lt;String&gt; stepCallback) {
<span class="nc bnc" id="L304" title="All 2 branches missed.">    if (graph.isEmpty()) {</span>
<span class="nc" id="L305">      return &quot;Graph is empty!&quot;;</span>
    }

<span class="nc" id="L308">    Random rand = new SecureRandom();</span>
<span class="nc" id="L309">    List&lt;String&gt; nodes = new ArrayList&lt;&gt;(graph.keySet());</span>
<span class="nc" id="L310">    String currentNode = nodes.get(rand.nextInt(nodes.size())); // 随机选择起始节点</span>
<span class="nc" id="L311">    StringBuilder walk = new StringBuilder(currentNode);</span>
<span class="nc" id="L312">    Set&lt;String&gt; visitedEdges = new HashSet&lt;&gt;();</span>

<span class="nc" id="L314">    stepCallback.accept(&quot;Step: &quot; + currentNode); // 打印第一个节点</span>

<span class="nc bnc" id="L316" title="All 4 branches missed.">    while (graph.containsKey(currentNode) &amp;&amp; !graph.get(currentNode).isEmpty()) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">      if (stopSignal.get()) {</span>
<span class="nc" id="L318">        break;</span>
      }
<span class="nc" id="L320">      Map&lt;String, Integer&gt; neighbors = graph.get(currentNode);</span>
<span class="nc" id="L321">      List&lt;String&gt; neighborList = new ArrayList&lt;&gt;(neighbors.keySet());</span>
<span class="nc" id="L322">      String nextNode = neighborList.get(rand.nextInt(neighborList.size())); // 随机选择下一个节点</span>
<span class="nc" id="L323">      String edge = currentNode + &quot;-&gt;&quot; + nextNode;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">      if (visitedEdges.contains(edge)) {</span>
<span class="nc" id="L325">        break;</span>
      }
<span class="nc" id="L327">      visitedEdges.add(edge);</span>
<span class="nc" id="L328">      currentNode = nextNode;</span>
<span class="nc" id="L329">      walk.append(&quot; -&gt; &quot;).append(currentNode);</span>

<span class="nc" id="L331">      stepCallback.accept(&quot;Step: &quot; + currentNode); // 处理当前步骤回调</span>

      try {
<span class="nc" id="L334">        Thread.sleep(1000); // 1秒延迟</span>
<span class="nc" id="L335">      } catch (InterruptedException e) {</span>
<span class="nc" id="L336">        Thread.currentThread().interrupt();</span>
<span class="nc" id="L337">        break;</span>
<span class="nc" id="L338">      }</span>
<span class="nc" id="L339">    }</span>

<span class="nc" id="L341">    String result = walk.toString();</span>
<span class="nc" id="L342">    try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(</span>
            new FileOutputStream(&quot;random_walk.txt&quot;), StandardCharsets.UTF_8))) {
<span class="nc" id="L344">      writer.write(result); // 将结果写入文件，指定使用UTF-8编码</span>
<span class="nc" id="L345">    } catch (IOException e) {</span>
<span class="nc" id="L346">      e.printStackTrace(); // 异常处理</span>
<span class="nc" id="L347">    }</span>

<span class="nc" id="L349">    return result;</span>
  }


  public void saveGraphImage(GraphPanel graphPanel, String filePath) throws IOException {
    File file;
<span class="nc" id="L355">    file = new File(FilenameUtils.getName(filePath));</span>
<span class="nc" id="L356">    graphPanel.saveGraphAsImage(file);</span>
<span class="nc" id="L357">  }</span>

  public static void main(String[] args) {
<span class="nc" id="L360">    SwingUtilities.invokeLater(() -&gt; {</span>
<span class="nc" id="L361">      TextGraphGui frame = new TextGraphGui();</span>
<span class="nc" id="L362">      frame.setVisible(true);</span>
<span class="nc" id="L363">    });</span>
<span class="nc" id="L364">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>